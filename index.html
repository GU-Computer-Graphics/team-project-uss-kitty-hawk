<!DOCTYPE html>
<html>

<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <title>Scene Demo</title>

    <style>
        /* feel free to change the canvas style. If you want to use the entire
      window, set width: 100% and height: 100% */
        canvas {
            display: block;
            margin: 10px auto;
            width: 700px;
            height: 500px;
        }

        h1 {
            text-align: center;
        }
    </style>

    <script src="./js/three.js"> </script>
    <script src="./js/SceneUtils.js"></script>
    <script src="./js/OrbitControls.js"></script>
    <script src="./js/dat.gui.js"></script>
    <script src="./js/jet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r126/three.min.js" integrity="sha512-n8IpKWzDnBOcBhRlHirMZOUvEq2bLRMuJGjuVqbzUJwtTsgwOgK5aS0c1JA647XWYfqvXve8k3PtZdzpipFjgg==" crossorigin="anonymous"></script>
    <script src="https://unpkg.com/three@0.126.0/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://unpkg.com/three@0.87.1/examples/js/controls/OrbitControls.js"></script>

    <script>
        //0. create any global variables used in your scene               

        var state = {};
        var ah = new THREE.AxesHelper(50);

        var cameraParams = {
            near: 1,
            far: 250,
            fov: 75,                // degrees
            aspectRatio: 700 / 500,   // from dimensions of the canvas, see CSS
            atX: 0,
            atY: 0,
            atZ: 0,
            eyeX: 0,
            eyeY: 60,
            eyeZ: -70,
            upX: 0,
            upY: 1,
            upZ: 0
        };



        // setupCamera() function creates and returns a camera with the desired parameters
        function setupCamera(cameraParameters) {
            // set up an abbreviation 
            var cp = cameraParameters;
            // create an initial camera with the desired shape
            var camera = new THREE.PerspectiveCamera(cp.fov, cp.aspectRatio, cp.near, cp.far);
            // set the camera location and orientation
            camera.position.set(cp.eyeX, cp.eyeY, cp.eyeZ);
            camera.up.set(cp.upX, cp.upY, cp.upZ);
            camera.lookAt(new THREE.Vector3(cp.atX, cp.atY, cp.atZ));
            return camera;
        }

        function redoCamera() {
            scene.remove(camera);
            camera = setupCamera(cameraParams);
            scene.add(camera)
            render();
        }


        function render() {
            // a render function; assume global variables scene, renderer, and camera
            renderer.render(scene, camera);
        }

        function setupCameraControls() {
            var cameraControls = new THREE.OrbitControls(camera, canvas);
            state.cameraControls = cameraControls;
            cameraControls.addEventListener('change', render);
            cameraControls.update();
        }
    </script>

</head>

<body>

    <h1>Aircraft Carrier Demo</h1>

    <script>

const _VS =

`

float rand(vec2 co){
  return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);
}
uniform float time;
varying vec3 worldPosition;

void main() {


  const float pi = 3.1415926535897932384626433832795;
  vec3 position = position;
  float time = time;
  float offset = rand(position.xy);



  position.z += (sin(0.25 * pi * position.x + time + offset) + sin(0.33 * pi * position.y + time + offset) + sin(0.5 * pi * position.x + time + offset) )* 0.4 + offset * 0.2;
  worldPosition = position;



  vec3 scale = vec3(1, 1, 1);
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position*scale, 1.0);

}`



const _FS = 
`
varying vec3 worldPosition;
uniform float time;
uniform float red_power;
uniform float green_power;
uniform float blue_power;
uniform float red_offset;
uniform float green_offset;
uniform float blue_offset;
uniform float max_blue;
uniform float max_green;
uniform float max_red;
uniform float min_blue;
uniform float min_green;
uniform float min_red;
uniform float height_offset;
void main(){

  // scale z to be between 0 and 1
  float scaledZ = (worldPosition.z + 5.0) / 10.0;
  scaledZ = scaledZ + height_offset;

  //set rgb to be blue at middle and white at top
  float red = red_offset - pow(scaledZ, red_power);
  float green = green_offset - pow(scaledZ, green_power);
  float blue = blue_offset - pow(scaledZ, blue_power);

  if (blue < min_blue) {
    blue = min_blue;
  }else if (blue > max_blue) {
    blue = max_blue;
  }
  if (green < min_green) {
    green = min_green;
  }else if (green > max_green) {
    green = max_green;
  }
  if (red < min_red) {
    red = min_red;
  }else if (red > max_red) {
    red = max_red;
  }





  gl_FragColor = vec4(red, green, blue, 1.0);


}`

        var oceanParams = {
            time_increment: 0.05,
            red_power: 1.5,
            green_power: 2.4,
            blue_power: 0.6,
            red_offset: 0.6,
            green_offset: 0.6,
            blue_offset: 1.3,
            max_blue: 1.0,
            max_green: 1.0,
            max_red: 1.0,
            min_blue: 0.0,
            min_green: 0.0,
            min_red: 0.0,
            height_offset: 0.33

        };

        var state = {}
        //1.  Create an initial empty Scene
        var scene = new THREE.Scene();


        var water_box_geom = new THREE.BoxGeometry(400, 400, 1, 200,200,1);

        var water_box_mat = new THREE.ShaderMaterial({
        uniforms: {
            time: { value: 0.0 },
            color: { value: new THREE.Color(0x0000ff),
            },
            red_power: { value: oceanParams.red_power },
            green_power: { value: oceanParams.green_power },
            blue_power: { value: oceanParams.blue_power},
            red_offset: { value: oceanParams.red_offset },
            green_offset: { value: oceanParams.green_offset },
            blue_offset: { value: oceanParams.blue_offset },
            max_blue: { value: oceanParams.max_blue },
            max_green: { value: oceanParams.max_green },
            max_red: { value: oceanParams.max_red },
            min_blue: { value: oceanParams.min_blue },
            min_green: { value: oceanParams.min_green },
            min_red: { value: oceanParams.min_red },
            height_offset: { value: oceanParams.height_offset }
        },
        vertexShader: _VS,
        fragmentShader: _FS,
        side: THREE.DoubleSide,
        wireframe: false
        });
        water_box_mat.uniforms.time.value = 0.0;


        var water_box = new THREE.Mesh(water_box_geom, water_box_mat);
        water_box.position.set(0, 0, 0);
        water_box.rotation.x = Math.PI / 2;
        scene.add(water_box);

        var water_box_2 = new THREE.Mesh(water_box_geom, water_box_mat);
        water_box_2.rotation.x = Math.PI / 2;
        water_box_2.rotation.z = Math.PI / 4;
        scene.add(water_box_2);


        let jet1 = createJet();
        jet1.position.set(0, 10, 0);
        jet1.scale.set(0.2, 0.2, 0.2);
        scene.add(jet1);

        play_jet_takeoff_animation(jet1)


        let bright_ambient = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(bright_ambient);

        // load aircraft carrier object into the scene
         let loader = new THREE.GLTFLoader();
         loader.crossOrigin = true;
         loader.load( 'cv-assets/USS_Kitty_Hawk.glb', function(data) {
             let cv = data.scene;
             cv.position.set(0, -10, -0.75);
             scene.add(cv);
         });



        //5. Create a renderer to render the scene
        var renderer = new THREE.WebGLRenderer();


        var canvas = renderer.domElement;
        //note state has been created as a global so we can modify it later if we desire
        state.renderer = renderer;  // save this so that others can use it.
        state.scene = scene;        // save this so that others can use it.
        var parent = document.body;
        parent.appendChild(canvas);
        renderer.setSize(canvas.clientWidth, canvas.clientHeight);
        renderer.setClearColor(new THREE.Color(0x2f2f2f), 1); //darker greyish... it's evening!

        //7. Set up a camera for the scene
        var camera = setupCamera(cameraParams);
        scene.add(camera);

        //set up camera controls so we can use mouse to pan around scene
        setupCameraControls();

        //add axishelper to scene -- created as a global variable
        ah.position.y += 3
        scene.add(ah);

        render()


        function onestep(){
            water_box_mat.uniforms.time.value += oceanParams.time_increment;
            render();
        }

        //create interval to call onestep every 100ms
        var interval = setInterval(onestep, 1000/60);


        //need to add keypress callback because we ditched TW script!
        document.addEventListener("keypress", (event) => {
            const key = event.key;
            console.log("Key pressed: " + key);
    
            
            setupCameraControls(); //probably a better way to fix this...
        });
    </script>


</body>

</html>